<?xml version="1.0" encoding="UTF-8"?><xml><records><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Baresi, Luciano</author><author>Heckel, Reiko</author><author>Thöne, Sebastian</author><author>Varró, Dániel</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Modeling and Analysis of Architectural Styles Based on Graph Transformation A Case Study on Service-Oriented Architectures</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Modeling and Analysis of Architectural Styles Based on Graph Transformation.pdf</url></pdf-urls></urls><label>Budapest University of Technology and Economics;Europe;Germany;Hungary;Italy;Politecnico di Milano;Univerität Paderborn;University</label><abstract>Modern architectural styles, like the service-oriented style underlying web services, are highly dynamic. This compli- cates not only their practical application, but also the mod- eling and prediction of their behavior. To account for this problem, we propose to model architectures as graphs, rep- resented as instances of UML class diagrams, and to describe their reconfigurations by graph transformation rules. Based on a sample model for service-oriented architectures, we dis- cuss what properties are interesting to be analyzed and how such analysis could be performed.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Barnett, Mike</author><author>Grieskamp, Wolfgang</author><author>Kerer, Clemens</author><author>Schulte, Wolfram</author><author>Szyperski, Clemens</author><author>Tillman, Nikolai</author><author>Watson, Arthur</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Serious Specification for Composing Components</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Serious Specification for Composing Components.pdf</url></pdf-urls></urls><label>Microsoft;North America;Private Company;USA</label><abstract>We discuss the use of an industrial-strength specification language to specify component-level contracts for a product group within Microsoft. We outline how the specification language evolved to meet the needs of the component-based ap- proach followed by that group. The specification language, AsmL, is executable which allows for testing to be done using runtime verification. Runtime verification dynamically monitors the behavior of a component to ensure that it conforms to its specification</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Bertolino, Antonia</author><author>Mirandola, Raffaela</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Towards Component-Based Software Performance Engineering Raffaela Mirandola</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Towards Component-Based Software Performance Engineering.pdf</url></pdf-urls></urls><label>Europe;Institute;Istituto di Scienza e Technologia;Italy;Universita di Roma;University</label><abstract>Early and rigorous performance analysis of component-based systems is a crucial issue in software engineering to guarantee that the developed components and their assemblies will satisfy their quality requirements. We propose an original approach, called the CB-SPE, for component-based software performance engineering. CB-SPE relies on, and adapts to a CB framework, the concepts and steps of the SPE technology and uses for modeling the standard RT-UML profile, reshaped according to the CB principles. The approach is compositional in that it is applied first at the component layer for achieving parametric performance evaluation of the component in isolation, and then at the application layer for predicting the performance of the assembled components on the actual platform. We also outline the architecture of a tool supporting the automation of the proposed approach, and overview related work.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Cervantes, Humberto</author><author>Hall, Richard S</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Automating Service Dependency Management in a Service-Oriented Component Model</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords><keyword>Components</keyword><keyword>OSGi</keyword><keyword>service-oriented programming</keyword></keywords><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Automating Service Dependency Management in a Service-Oriented Component Model.pdf</url></pdf-urls></urls><label>Domaine Universitaire;Europe;France;University</label><abstract>This paper describes a mechanism to automate service depend- ency management in a service-oriented component model. The impetus behind this mechanism is not merely to eliminate com- plex and error-prone code from component-based applications, but also to deal with the phenomena of application building blocks that exhibit dynamic availability, i.e., they may appear or disappear at any time and this is not under the control of the ap- plication. This intense focus on dynamic availability of building blocks is the result of the belief that applications of the future will become context aware in order to deal with building block proliferation. Such applications will employ context-aware archi- tectures that use context (e.g., location, environment, user task) as a filter for including/excluding building blocks in/from their compositions. In this vision, automatic handling of dynamically available building blocks and their impact on application com- position is critical. The service dependency management mech- anism described in this paper is a starting point for such re- search and is implemented on top of the Open Services Gateway Initiative (OSGi) framework. The concepts and solutions it provides are sufficiently general for application in other service- oriented component models.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>DePrince, Wayne Jr.</author><author>Hofmeister, Christine</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Usage Policies for Components</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords><keyword>architectural constraints</keyword><keyword>architecture description language</keyword><keyword>component</keyword><keyword>component model</keyword><keyword>component specification</keyword><keyword>corba</keyword><keyword>ejb</keyword><keyword>idl</keyword></keywords><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Specifying Architectural Constraints on Components.pdf</url></pdf-urls></urls><label>Lehigh University;North America;USA;University</label><abstract>Research to improve component reuse has focused on providing the specification of various behavior properties. In this paper we present our approach to this problem, which focuses not so much on specifying the behavior of the component, but instead on certain architectural constraints. We introduce our research project “lips”, a language for formally capturing these usage constraints and a toolset for automatically providing for their enforcement at runtime. Our approach captures the usage constraints that are local to a particular component. In this way we express these restrictions on its reuse independent of an actual client or application. We then embed these constraints within the component’s specification. Our toolset verifies that the component conforms to the specification and uses it to generate code which checks if the constraints are obeyed by clients at runtime.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Dijkman, Remco M</author><author>Andrade Almeida, João Paulo</author><author>Quartel, Dick A C</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Verifying the Correctness of Component-Based Applications that Support Business Processes</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Verifying the Correctness of Component-Based Applications that Support Business Processes.pdf</url></pdf-urls></urls><label>Europe;Netherlands;University of Twente</label><abstract>Developing applications that properly support the enterprise is a difficult task. Failing to perform this task results in applications that are not accepted by the end-users and that frustrate daily conduct of business. In this paper we introduce a formal yet practical method that helps to design component- based applications that properly support the enterprise. The method can be used to verify whether the behavior of an application conforms to the behavior of the enterprise, where the behavior of the enterprise is specified in the form of business processes. The method helps to avoid applications being designed that support the enterprise in an incorrect manner.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Hamlet, Dick</author><author>Andrić, Milan</author><author>Tu, Zheng</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Experiments with Composing Component Properties</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><issue>2</issue><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Experiments with composing component properties.pdf</url></pdf-urls></urls><label>North America;Portland State University;USA;University</label><abstract>A detailed, microscopic theory of software component com- position into systemswas presented in thisworkshop in 2000 and subsequently at ICSE 2001. The essential idea of this theory is that by decomposing the input domain of a compo- nent into appropriate subdomains, its properties can be mea- sured so that a system developer can later use the measure- ments, factoring in usage and system-structure information when such system-defined information is available. In prin- ciple, the theory could be the basis for aCADtool supporting system design, which would take as input: (1) the black-box components, (2) their developers’ subdomains and property measurements, and (3) a proposed system structure. The CAD tool could then calculate the system properties to be expected. This compositional theory was originally proposed for the reliability property, but it was soon recognized that it applies to almost any component/system property that is input- and structure-dependent. In particular, the run-time property is an ideal one for experimentation, because it is easier to mea- sure than reliability, and does not depend on the somewhat dubious background theory of software reliability. While re- liability measurements require random testing, run time mea- surements can be made systematically, since there is no issue of failure correlation. Thus run times can be measured with fewer evenly distributed test points. We report on initial validation experiments for this theory, using a rudimentary CAD tool that does calculations of run times. These experiments address the basic validity of the theory and the efficiency of the system-design calculations.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Heineman, George T</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Integrating Interface Assertion Checkers into Component Models</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords><keyword>component models</keyword><keyword>interfaces</keyword><keyword>run-time behavioral contracts</keyword></keywords><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Integrating Interface Assertion Checkers into Component Models.pdf</url></pdf-urls></urls><label>Institute;North America;USA;Worcester Polytechnic Institute</label><abstract>Run-time enforcement of behavioral contracts has been studied extensively in procedural and object-oriented languages. This research has led to a better understanding of specific techniques, including pre-processing compilers or wrappers. However, component-based software engineering (CBSE) imposes additional restrictions and it is appropriate to consider how to extend these techniques when the software is decomposed into independently-developed third-party components. In this paper we identify some requirements for integrating run-time enforcement of behavioral contracts into the component model and illustrate a solution using a scaled-down component model and example. The primary result is that a standardized service should be added to component model implementations to enable application assemblers to enforce local properties as specified by the components in the application as well as global properties as specified by the application.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Inverardi, Paola</author><author>Tivoli, Massimo</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>A compositional synthesis of failure-free connectors for correct components assembly</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://A compositional synthesis of failure-free connectors for correct components assembly.pdf</url></pdf-urls></urls><label>Europe;Italy;University;University of L'Aquila</label><abstract>Correct automatic assembly of software components is con- sidered an important issue of CBSE (Component-Based Soft- ware Engineering). It is related to the ability to establish properties on the assembly code by only assuming a rela- tive knowledge of the single components properties. In our precedent works, we have provided our answer to this prob- lem by discussing a software architecture based approach in which the software architecture imposed on the assembly allows for detection and recovery of COTS (Commercial- Off-The-Shelf ) integration anomalies. One of the crucial aspects of our assembly technique is related to the ability to synthesize a specification-satisfying assembly code (i.e. the failures-free connector) in such a way that the synthesis re- sults compositional with respect to system evolutions. That is every time the system evolves, in order to automatically synthesize the failures-free connector for the new version of the specification-satisfying system it is enough to repeat the synthesis only for the part of the system related to its evo- lution.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Jia, Yinghua</author><author>Atlee, Joanne M</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Run-Time Management of Feature Interactions</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Run-Time Management of Feature Interactions.pdf</url></pdf-urls></urls><label>Canada;North America;University;University of Waterloo</label><abstract>There is a push to develop feature-rich applications as collections of interconnected feature modules. The problem is that these modules are conceived as independent features, but when strung together, they may interfere with each other because they modify the same shared data (e.g., two features may inconsistently update variables that are encapsulated in a third module). We are studying how to support modu- lar feature development via a framework that interconnects features and that automatically detects and resolves fea- ture interactions. In this paper, we propose a component model for coordinating features and we describe a proto- type framework that implements this model.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Jonge, Merijn De</author><author>Muskens, Johan</author><author>Chaudron, Michel</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Scenario-Based Prediction of Run-time Resource Consumption in Component-Based Software Systems</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Scenario-Based Prediction of Run-time Resource Consumption in Component-Based Software Systems.pdf</url></pdf-urls></urls><label>Eindhoven University of Technology;Europe;Netherlands;University</label><abstract>Resources of embedded systems, such as memory size and CPU power, are expensive and (usually) not extensible during the lifetime of a system. It is therefore desirable to be able to determine the resource consumption of an appli- cation as early as possible in the design phase. Only then, a designer is able to guarantee that an application will fit on a target device. Resource prediction is a technique to estimate the amount of consumed resources by analyzing the design and/or implementation of an application. In this pa- per we concentrate on predicting memory consumption in component-based applications. Component-based appli- cations complicate resource predictions because resource consumption is spread across individual components. The challenge is to express resource consumption per component, and to combine them to do predictions over compositions of components. To that end, we propose a model in which individual resource estimations of compo- nents can be combined. These composed resource estima- tions are then used in scenarios (which model run-time be- havior) to predict memory consumption of applications.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Mcgregor, John D</author><author>Stafford, Judith A</author><author>Cho, Il-Hyung</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Measuring Component Reliability Il-Hyung Cho</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Measuring Component Reliability.pdf</url></pdf-urls></urls><label>Clemson University;North America;Tufts University;USA;University</label><abstract>Much of the research on component-based software engineering assumes that each component has a single service. This simplifies analyses but it is a significant departure from actual components. This paper reports on an investigation of the feasibility of using design constructs as a means of treating several methods as a single unit. Grouping the services of a component into a few sets satisfies the goal of simplicity while still providing the designer with a more usable model of component reliability.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Mehlitz, Peter C</author><author>Penix, John</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Design for Verification Using Design Patterns to Build Reliable Systems</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Design for Verification Using Design Patterns to Build Reliable Systems.pdf</url></pdf-urls></urls><label>Institute;NASA;North America;USA</label><abstract>In commercial software development, components are mainly used to reduce time to market. While some effort has been spent on formal aspects of components, most of this was done in the context of integration into programming languages or operating system frameworks. As a consequence, increased reliability of composed systems is merely regarded as a side effect of a more rigid testing of pre-fabricated components. In contrast to this, Design for Verification (D4V) puts the focus on component-specific property guarantees, which are used to design systems with high reliability requirements. D4V components are domain specific design pattern instances with well-defined property guarantees and usage rules, which are suitable for automatic verification. The guaranteed properties are explicitly used to select components according to key system requirements. The D4V hypothesis is that the same general architecture and design principles leading to good modularity, extensibility and complexity/functionality ratio can be adapted to overcome some of the limitations of conventional reliability assurance methods, such as too large a state space or too many execution paths.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Sridhar, Nigamanth</author><author>Hallstrom, Jason O</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Generating Configurable Containers for Component-Based Software</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords><keyword>automated software engineering</keyword><keyword>component software</keyword><keyword>containers</keyword><keyword>design patterns</keyword><keyword>templates</keyword></keywords><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Generating Configurable Containers for Component-Based Software.pdf</url></pdf-urls></urls><label>North America;Ohio State University;USA;University</label><abstract>Existing container-based development strategies provide solutions to the problem of encapsulating cross-cutting concerns in component-based software systems. These approaches fall short, however, in enabling tractable reasoning. To extend existing work in reasoning about parameterized components to container-based approach- es, we view containers as parameterized components. We present a model of component containers based on Service Facilities (Serfs) [18] — a design pattern frame- work that supports the construction of parameterized components that supports dynamic binding. To ease the transition to this new approach, we present the de- sign of a tool that automatically generates Serf contain- ers for existing component libraries.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Vecellio, Gary J</author><author>Thomas, William M</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Infrastructure Support for Predictable Policy Enforcement</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords/><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Infrastructure Support for Predictable Policy Enforcement.pdf</url></pdf-urls></urls><label>MITRE Corporation;North America;Private Company;USA</label><abstract>Component and service-based application infrastructures provide mechanisms for efficiently composing a system from a diverse collection of components and services. However, because of the lack of insight into the components and services within the application, integrating changes can be challenging. One class of change that we perceive as being both common and necessary is in the area of policy adherence (i.e., the constraints on a system’s behavior that are imposed across the system). Unless the mechanisms that implement the policy are well isolated from the core application logic, any upgrade to the policy can have a ripple effect through the system. For systems that require robust certification, this ripple effect hampers the ability to rapidly deploy changes in policy. In this paper we highlight some patterns for separating policy adherence from application core logic, and discuss how these patterns can be mapped to commercially available infrastructures. By realizing these patterns as common infrastructure extensions, we allow applications to be developed in a manner consistent with the commercial infrastructure, provide the power of policy enforcement mechanisms to the system developers, and separate the policy enforcement logic from core application functionality.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Weide, Bruce W</author><author>Ogden, William F</author><author>Sitaraman, Murali</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Expressiveness Issues in Compositional Performance Reasoning</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords><keyword>abstract data type</keyword><keyword>analysis of algorithms</keyword><keyword>component</keyword><keyword>component-based software</keyword><keyword>execution time</keyword><keyword>expressiveness</keyword><keyword>formal specification</keyword><keyword>model-based specification</keyword><keyword>performance analysis</keyword><keyword>performance specification</keyword><keyword>specification</keyword></keywords><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Expressiveness Issues in Compositional Performance Reasoning.pdf</url></pdf-urls></urls><label>Clemson University;North America;Ohio State University;USA;University</label><abstract>Compositional reasoning about any behavioral property of a system depends, first, on the ability to express that property for both individual components and systems constructed from them. Expressiveness problems arise when considering compositional reasoning about performance in the presence of complex user-defined types (as opposed to simpler built-in types). There are interesting implications not just for compositional reasoning but for language design and for formal specification.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Wu, Xiuping</author><author>Mcmullan, David</author><author>Woodside, Murray</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>Component Based Performance Prediction</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><pages>1-6</pages><volume>2003</volume><keywords><keyword>assembly model</keyword><keyword>cbse</keyword><keyword>component based software engineering</keyword><keyword>performance prediction</keyword><keyword>performance submodels</keyword></keywords><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://Component Based Performance Prediction.pdf</url></pdf-urls></urls><label>Canada;Carleton University;North America;University</label><abstract>Component Based Software Engineering (CBSE) exploits re-usability of configurable components to generate software products more quickly, and with higher quality. CBSE offers potential advantages for performance engineering. If most of a new system consists of existing software components, it should be possible to predict properties like performance more easily, than if all of the software is new. The performance-sensitive properties of the components can be extracted and stored in a library, and used to build a predictive model for the performance of a proposed product. This paper describes an approach based on performance submodels for each component, and a system assembly model to describe the binding together of library components and new components into a product. In this work a component can be arbitrarily complex, including a subsystem of concurrent processes. The description pays particular attention to identifying the information that must be provided with the components, and with the bindings, and to providing for parameterization to describe different configurations and workloads.</abstract></record><record><database name="2003.enl" path="2003.enl">2003.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Zhao, Wei</author><author>Bryant, Barrett R</author><author>Raje, Rajeev R</author><author>Auguston, Mikhail</author><author>Gray, Jeffrey G</author><author>Burt, Carol C</author><author>Olson, Andrew M</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Schmidt, Heinz</author><author>Stafford, Judith</author><author>Wallnau, Kurt</author></secondary-authors></contributors><titles><title>A Generative and Model Driven Framework for Automated Software Product Generation</title><secondary-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</secondary-title></titles><periodical><full-title>Automated Reasoning and Prediction 6th ICSE Workshop on Component-Based Software Engineering (CBSE)</full-title></periodical><volume>2003</volume><keywords><keyword>application engineering</keyword><keyword>component-based software engineering</keyword><keyword>domain engineering</keyword><keyword>feature modeling</keyword><keyword>generative programming</keyword><keyword>generic modeling environment</keyword><keyword>model driven architecture</keyword><keyword>two-level grammar</keyword></keywords><dates><year>2003</year></dates><pub-location>Portland, Oregon USA</pub-location><urls><pdf-urls><url>internal-pdf://A Generative and Model Driven Framework for Automated Software Product Generation.pdf</url></pdf-urls></urls><label>Naval Postgraduate School;North America;Purdue University;USA;University;University of Alabama at Birmingham</label><abstract>Component-based Software Engineering (CBSE) and related technologies have demonstrated their strength in recent years by increasing development productivity and parts reuse. Recently, the Model Driven Architecture (MDA) has raised the abstraction level of programming languages to modeling languages that can be compiled by downward model transformations. Correspondingly, the goal of Generative Programming (GP) is to automate concrete software product generation from a domain- specification and reusable components. This paper describes the UniFrame framework, which is built on the foundation of CBSE while leveraging the capabilities offered by MDA and GP. UniFrame provides theories and implementation for steps of model transformations for a concrete software product based on domain development in various Generative Domain Models (GDMs).</abstract></record></records></xml>
