<?xml version="1.0" encoding="UTF-8"?><xml><records><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Abate, Pietro</author><author>Treinen, Ralf</author><author>Cosmo, Roberto Di</author><author>Zacchiroli, Stefano</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>MPM : A Modular Package Manager</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>179-187</pages><keywords><keyword>package managers</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://MPM a modular package manager.pdf</url></pdf-urls></urls><label>Europe;France;Universite Paris Diderot</label><abstract>Software distributions in the FOSS world rely on so-called package managers for the installation and removal of pack- ages on target machines. State-of-the-art package managers are monolithic in architecture, and each of them is hard- wired to an ad-hoc dependency solver implementing a cus- tomized heuristics. In this paper we propose a modular architecture allowing for pluggable dependency solvers and backends. We argue that this is the path that leads to the next generation of package managers that will deliver bet- ter results, accept more expressive input languages, and can be easily adaptable to new platforms. We present a work- ing prototype—called MPM—which has been implemented following the design advocated in this paper.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Abdellatif, Takoua</author><author>Sfaxi, Lilia</author><author>Lakhnech, Yassine</author><author>Robbana, Riadh</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Automating Information Flow Control in Component-based</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>73-82</pages><keywords><keyword>component-based distributed system</keyword><keyword>information flow control</keyword><keyword>secure system configuration and deployment</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Automating information flow control in component-based distributed systems.pdf</url></pdf-urls></urls><abstract>Automating the construction of secure distributed systems becomes necessary. Indeed, developing security code re- quires a deep expertise and verifying that the developed code respects the specified policy is a tedious task. In this paper, we define a toolkit called CIF (Component Information Flow) that automates the development of secure dis- tributed systems. The developer defines the security properties through a policy configuration file. When this config- uration is validated, that is no security leak is detected, the system security code is generated. A performance evaluation of an implemented use case shows the effectiveness of the approach.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Aleti, Aldeida</author><author>Meedeniya, Indika</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Component Deployment Optimisation with Bayesian Learning</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>11-20</pages><keywords><keyword>architecture optimisation</keyword><keyword>bayesian learning</keyword><keyword>component deployment</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Component deployment optimisation with bayesian learning.pdf</url></pdf-urls></urls><label>Australia;Swinburne University of Technology;University</label><abstract>Implementing embedded software systems involves many im- portant design decisions, such as finding (near) optimal com- ponent deployment architectures, that have a strong influence on the quality of the final system perceived by its users. These decisions are difficult not only because of the complexity of current systems, but also due to the large number of possible design options. An automation of the design space exploration will help to make better decisions and to reduce the time of this process. In this paper, a new method called Bayesian Heuristic for Component Deployment Optimisation (BHCDO) is proposed. BHCDO constructs solutions based on a Bayesian learning mechanism which guides the search for assignments that result in new deployment architectures with an improved quality. This is achieved by calculating the posterior probability that a particular component- host assignment is a good decision, resulting in a high quality deployment architecture, given some observed evidence during the search. Experiments on a series of randomly generated problems show that BHCDO efficiently automates the search for component deployment design alternatives and outperforms state of the art optimisation methods.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Borde, Etienne</author><author>Carlson, Jan</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Towards Verified Synthesis of ProCom , a Component Model for Real-Time Embedded Systems</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>129-138</pages><keywords><keyword>Component BasedModel</keyword><keyword>Embedded Systems</keyword><keyword>Real-Time</keyword><keyword>Synthesis</keyword><keyword>Verification</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Towards verified synthesis of ProCom, a component model for real-time embedded systems.pdf</url></pdf-urls></urls><label>Europe;France;Institut TELECOM;Institute;Malardalen Real-Time Research Centre;Sweden</label><abstract>To take advantage of component-based software engineering, software designers need a component framework that auto- mates the assemblage and integration of developed compo- nents. It is then of prime importance to ensure that the synthesized code respects the definition of the component model’s semantics. This is all the more difficult in the domain of embedded systems since the considered semantics usually aims at characterizing both functional proper- ties (e.g. data and control dependencies) and non-functional properties such as timing and memory consumption. The component model considered in this paper, called ProCom, relies on an asynchronous operational semantics and a formal hypothesis of atomic and instantaneous interactions between components. The asynchronous approach targets higher flexibility in the deployment and analysis pro- cess, while the formal hypothesis helps in reducing the com- binatory problems of formal verification. In this paper, we present a code generation strategy to synthesize ProCom components, and a formalization of this generated code. This formalization extends the verification possibilities of ProCom architectures, and constitutes a step toward the verification that the produced code respects the operational semantics of ProCom.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Cicchetti, Antonio</author><author>Ciccozzi, Federico</author><author>Leveque, Thomas</author><author>Sentilles, Severine</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Evolution management of extra-functional properties in component-based embedded systems</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>93</pages><keywords><keyword>component based software engineering</keyword><keyword>context</keyword><keyword>evolution management</keyword><keyword>extra-functional properties</keyword><keyword>impact analysis</keyword><keyword>model driven engineering</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><publisher>ACM Press</publisher><isbn>9781450307239</isbn><electronic-resource-num>10.1145/2000229.2000243</electronic-resource-num><urls><pdf-urls><url>internal-pdf://Evolution management of extra-functional properties in component-based embedded systems.pdf</url></pdf-urls><web-urls><url>http://portal.acm.org/citation.cfm?doid=2000229.2000243</url></web-urls></urls><label>Europe;Malardalen Real-Time Research Centre;Sweden;University</label><abstract>As software complexity increases in embedded systems domain, component-based development becomes increasingly attractive. A main challenge in this approach is however to analyze the system’s extra-functional properties (such as timing properties, or resource requirements), an important step in a development of embedded systems. Analysis of such properties are computational and time consuming, and often difficult. For this reason reuse of the results of the analysis is as important as the reuse of the component itself, especially in case of modifications of the context in which the component is used. This paper presents concepts and mechanisms that allow to automatically discover whether a property value is still valid when related components evolve: a value context language is proposed to formally define the validity conditions and identify possible threats.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Distefano, Salvatore</author><author>Filieri, Antonio</author><author>Ghezzi, Carlo</author><author>Mirandola, Raffaela</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>A Compositional Method for Reliability Analysis of Workflows Affected by Multiple Failure Modes</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>149-158</pages><keywords/><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://A compositional method for reliability analysis of workflows affected by multiple failure modes.pdf</url></pdf-urls></urls><label>Europe;Italy;Politecnico di Milano;University;Unversita di Messina</label><abstract>We focus on reliability analysis for systems designed as workflow- based compositions of components. Components are characterized by their failure profiles, which take into account possible multiple failure modes. Acompositional calculus is provided to evaluate the failure profile of a composite system, given failure profiles of the components. The calculus is described as a syntax-driven procedure that synthesizes a workflow’s failure profile. The method is viewed as a design-time aid that can help software engineers rea- son about system’s reliability in the early stage of development. A simple case study is presented to illustrate the proposed approach.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Gregersen, Allan Raundahl</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Implications of Modular Systems on Dynamic Updating</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>169-178</pages><keywords><keyword>dynamic code evolution</keyword><keyword>dynamic updating</keyword><keyword>Module-based dynamic updating</keyword><keyword>runtime evolution.</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Implications of modular systems on dynamic updating.pdf</url></pdf-urls></urls><label>Denmark;Europe;University;University of Southern Denmark</label><abstract>Module systems have been acknowledged as to increase software development and maintenance boosters. Likewise, dynamic updating, meaning the ability to evolve a software system at runtime, not only has the potential developer productivity, but also to significantly reduce production system downtime. However, widely adopted module systems for Java inherently enforces assumptions that make dynamic updates of modules difficult, even with the recent prominent advances in dynamic updating systems for Java applications. In this paper, we explain why it requires much more than just updating the set of Java classes that constitute a patched version of a running module. In addition, we provide a set of well-defined integration points to which developers of dynamic updating systems need to hook into in order to support correct dynamic updating in a module system. We show how our dynamic updating system has been integrated with the NetBeans Platform with a modest integration effort, thus showcasing that practical state-preserving runtime updates of modules can be achieved in a modern module system setup.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Heinzemann, Christian</author><author>Henkler, Stefan</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Reusing Dynamic Communication Protocols in Self-Adaptive Embedded Component Architectures Categories and Subject Descriptors</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>109-118</pages><keywords><keyword>Dynamic Structures</keyword><keyword>Refinement</keyword><keyword>Safety-Critical Systems</keyword><keyword>Self-Adaptive Systems</keyword><keyword>Verification</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Reusing dynamic communication protocols in self-adaptive embedded component architectures.pdf</url></pdf-urls></urls><label>Europe;Germany;OFFIS;Univerität Paderborn;University</label><abstract>Component based software engineering aims at re-using compo- nents in other systems. This requires a verification whether the component can safely interact with its communication partners in a new environment. Such verification is mandatory in case of safety- critical real-time systems where the communication is character- ized by a varying number of components instances all being of the same type. Reuse can be facilitated by separating abstract commu- nication protocol definitions and concrete component implemen- tations. In contrast to standard refinement definitions for real-time systems, our definition explicitly takes varying numbers of commu- nication partners into account. Additionally, we relax the strict con- ditions of a bisimulation to ease reuse of components. Along with our refinement definition, we provide a formal verification proce- dure to check for correct refinements which preserves properties verified for the abstract protocol definition. We evaluated our ap- proach using a self-adaptive real-time system from the domain of autonomous train systems. The evaluation results show that check- ing for correct refinements is more efficient than re-verifying the desired properties on the refined component.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Huang, Gang</author><author>Wu, Yihan</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Towards Architecture-Level Middleware-Enabled Exception Handling of Component-based Systems</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>159-168</pages><keywords><keyword>Exception handling</keyword><keyword>JEE</keyword><keyword>middleware</keyword><keyword>software architecture</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Towards architecture-level middleware-enabled exception handling of component-based systems.pdf</url></pdf-urls></urls><label>Asia;China;Peking University;University</label><abstract>Exception handling is a practical and important way to improve the availability and reliability of a component-based system. The classical code-level exception handling approach is usually applied to the inside of a component, while some exceptions can only or properly be handled outside of the components. In this paper, we propose a middleware-enabled approach for exception handling at architecture level. Developers specify what exceptions should be handled and how to handle them with the support of middleware in an exception handling model, which is complementary to software architecture of the target system. This model will be interpreted at runtime by a middleware-enabled exception handling framework, which is responsible for catching and handling the specified exceptions mainly based on the common mechanisms provided by the middleware. The approach is demonstrated in JEE application servers and benchmarks.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Inoue, Taku</author><author>Honiden, Shinichi</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>A method for data-flow analysis of business components</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>51</pages><keywords><keyword>component</keyword><keyword>data-flow analysis</keyword><keyword>ocl</keyword><keyword>uml</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><publisher>ACM Press</publisher><isbn>9781450307239</isbn><electronic-resource-num>10.1145/2000229.2000237</electronic-resource-num><urls><pdf-urls><url>internal-pdf://A method for data-flow analysis of business components.pdf</url></pdf-urls><web-urls><url>http://portal.acm.org/citation.cfm?doid=2000229.2000237</url></web-urls></urls><label>Asia;Japan;University;University of Tokyo</label><abstract>Separation of concerns is an important aspect of component-based development (CBD), and managing data is a primary concern in enterprise systems. In CBD methods, such as Catalysis and UML components, this concern is addressed by business components. Although a business component is self-contained, having no di- rect dependency on any of the other components, the data propaga- tion between components may lead to indirect data dependencies across the business components, and grasping such dependencies at design-time is crucial to maintaining data consistency. In this paper we propose a method for data-flow analysis (DFA) of the business component model, in which the operational behavior is described using the Object Constraint Language (OCL) pre-/postconditions. Traditional DFA techniques are aimed at procedural descriptions, while OCL is a declarative language whose essential properties include nondeterminism and incompleteness. In order to extract a data-flow from the OCL descriptions taking account of their se- mantics, our proposed method applies the idea of abstract inter- pretation. We also analyze the safety of our abstract interpretation technique, and discuss the usefulness and scalability of the method from a practical viewpoint. The proposed method, when used in conjunction with the inter-procedural DFA techniques, would al- low us to extract the propagation and dependency of data across the business components automatically.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Jenson, Graham</author><author>Dietrich, Jens</author><author>Guesgen, Hans W</author><author>Marsland, Stephen</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>An Empirical Study into Component System Evolution</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>189-191</pages><keywords/><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://An empirical study into component system evolution.pdf</url></pdf-urls></urls><label>Australia;Massey University;New Zealand</label><abstract>When evolving component based systems, possible side ef- fects can be mitigated by changing only what is necessary. Identifying this minimal change is non-trivial, and exploring different heuristics used for this is the focus of this paper. We look at three different heuristics and compare their prop- erties while simulating evolution of an Ubuntu GNU/Linux distribution. This simulation involves randomly selecting components to install, then calculating the resulting system with respect to a heuristic over many generations. We look at the mean and volatility of change to a system to compare different heuristics, and find that simple heuristics can re- sult in minimal changes just as well as other more complex heuristics.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Koziolek, Anne</author><author>Reussner, Ralf</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Towards a generic quality optimisation framework for component-based system models</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>103</pages><keywords/><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><publisher>ACM Press</publisher><isbn>9781450307239</isbn><electronic-resource-num>10.1145/2000229.2000244</electronic-resource-num><urls><pdf-urls><url>internal-pdf://Towards a generic quality optimisation framework for component-based system models.pdf</url></pdf-urls><web-urls><url>http://portal.acm.org/citation.cfm?doid=2000229.2000244</url></web-urls></urls><label>Europe;Germany;Institute;Karlsruhe Institute of Technology</label><abstract>Designing component-based systems (CBS) that exhibit a good trade-off betweenmultiple quality criteria is hard. Even after functional design, many remaining degrees of freedom of different types (e.g. component deployment, component selection, server configuration) in the CBS span a large, dis- continuous design space. Automated approaches have been proposed to optimise CBS models, but they only consider a limited set of degrees of freedom, e.g. they only optimise the selection of components without considering the deploy- ment, or vice versa. We propose a flexible and extensible for- mulation of the design space for optimising any CBS model for a number of quality properties and an arbitrary number of degrees of freedom. With this design space formulation, a generic quality optimisation framework that is indepen- dent of the used CBS metamodel can apply multi-objective metaheuristic optimisation such as evolutionary algorithms.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Lau, Kung-kiu</author><author>Safie, Lily</author><author>Št, Petr</author><author>Tran, Cuong</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>A Component Model that is both Control-driven and</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>41-50</pages><issue>ii</issue><keywords><keyword>component model</keyword><keyword>control flow</keyword><keyword>data flow</keyword><keyword>separation of control and data</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://A component model that is both control-driven and data-driven.pdf</url></pdf-urls></urls><label>England;Europe;University;University of Manchester</label><abstract>In some industrial domains, it is beneficial to model systems that are both data-driven and control-driven. The challenge to component-based development (CBD) is to provide suit- able component models for this purpose. In this paper we propose such a component model. We define the model, and present a model-driven implementation. We also illustrate its application to an example from the automotive domain.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Lévêque, Thomas</author><author>Sentilles, Severine</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Refining Extra-Functional Property Values in Hierarchical Component Models Categories and Subject Descriptors</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>83-92</pages><keywords><keyword>component instance</keyword><keyword>component type</keyword><keyword>extra-functional properties</keyword><keyword>inheritance policy</keyword><keyword>multiple values</keyword><keyword>virtual workspace</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Refining extra-functional property values in hierarchical component models.pdf</url></pdf-urls></urls><label>Europe;Malardalen Real-Time Research Centre;Sweden;University</label><abstract>It is nowadays widely accepted that extra-functional properties (EFPs) are as important as functional properties for sys- tem correctness, especially when considering systems such as safety-critical embedded systems. The criticality and resource-constrained nature of these systems necessitate to be able to predict tight and accurate extra-functional property values all along the development, from early estima- tions to measurements. By using a hierarchical component model that allows implementing components as an assembly of subcomponent instances, the same component can be instantiated in several assemblies, i.e. in different usage contexts. Many EFP values are sensitive to the usage context and knowing information about the enclosing assembly enables refining the values of the properties on the subcomponents. Such refinement is usually not supported and the consistency between refined values and the original ones not ensured. This paper presents the concepts and mechanisms to support EFP refinement in hierarchical component models with explicit property inheritance and refinement policies which formally define consistency constraints between refined value and the original one. These policies are interpreted and ensured for all actors and in all workspaces. The paper also describes the related experiments performed on the ProCom component model.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Loiret, Frederic</author><author>Rouvoy, Romain</author><author>Seinturier, Lionel</author><author>Merle, Philippe</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Software Engineering of Component-Based Systems-of-Systems : A Reference Framework</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>61-65</pages><keywords/><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Software engineering of component-based systems-of-systems a reference framework.pdf</url></pdf-urls></urls><abstract>Systems-of-Systems (SoS) are complex infrastructures, which are characterized by a wide diversity of technologies and requirements imposed by the domain(s) they target. In this context, the software engineering community has been focus- ing on assisting the developers by providing them domain- specific languages, component-based software engineering frameworks and tools to leverage on the design and the development of such systems. However, the adoption of such approaches often prevents developers from combining sev- eral domains, which is a strong requirement in the context of SoS. Furthermore, only little attention has been paid to the definition of a modular toolset and an extensible runtime infrastructure for deploying and executing SoS. In this paper, we therefore propose a reference framework to leverage on the software engineering of SoS. Our reference framework has been validated on the development of two platforms, namely Hulotte and FraSCAti, to demonstrate that the resulting complexity is isolated in the core toolset, while the development of domain-specific extensions is leveraged and simplified by clearly identified abstractions.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Melo, Felipe Martins</author><author>Jr, Álvaro R Pereira</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>A Component-Based Open-Source Framework for General-Purpose Recommender Systems</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>67-71</pages><keywords/><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://A component-based open-source framework for general-purpose recommender systems.pdf</url></pdf-urls></urls><label>Brasil;Federal University of Ouro Preto;South America</label><abstract>Recommender systems constitute a new field that provides nowadays an important support for information search from huge amounts of data, since some of those information may be of interest of users but hard to be searched manually. According to forecasts, data production tends to grow more and more, which places recommender systems on the way to play a key role in mining those data. Technologies about to be adopted in large scale require tools to enable their mass production, and this fact is the key motivation of this work. In this paper we present our research in the field of component- based software engineering to design a framework for recommender systems. We have elicited the requirements that all recommender systems might address, and developed a vertical framework to support the development of such a sort of systems by designing components in accordance with those requirements. With the Idealize Recommendation Framework, we intend to make the development of recommender systems an easier, faster, and standardized process, as well as to perform the foundation of the technical terms to be used in the area.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Otte, William R</author><author>Gokhale, Aniruddha</author><author>Schmidt, Douglas C</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Predictable Deployment in Component-based Enterprise Distributed Real-time and Embedded Systems</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>21-30</pages><keywords><keyword>component-based real-time systems</keyword><keyword>predictable deployment</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Predictable deployment in component-based enterprise distributed real-time and embedded systems.pdf</url></pdf-urls></urls><label>North America;USA;University;Vanderbilt University</label><abstract>Component-basedmiddleware, such as the LightweightCOR- BA Component Model, are increasingly used to implement large-scale distributed real-time and embedded (DRE) systems. In addition to supporting the quality of service (QoS) requirements of individual DRE systems, component technologies must also support bounded latencies when effecting deployment changes to DRE systems in response to changing environmental conditions and operational requirements. This paper makes three contributions to the study of predictable deployment latencies in DRE systems. First, we de- scribe OMG’s Deployment and Configuration (D&amp;C) speci- fication for component-based systems and discuss how conventional implementations of this standard can significantly degrade deployment latencies. Second, we describe architectural changes and performance optimizations implemented within the Locality-Enhanced Deployment and Configura- tion Engine (LE-DAnCE) implementation of theD&amp;C speci- fication. Finally, we analyze the performance of LEDAnCE in the context of component deployments on 10 nodes for a representative DRE system consisting of 1,000 components. Our results show LE-DAnCE’s optimizations provide a bounded deployment latency of less than 2 seconds with 4 percent jitter.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Pires, Paulo F</author><author>Delicato, Flávia C</author><author>Pinto, Monica</author><author>Fuentes, Lidia</author><author>Marinho, Eberton</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Software Evolution in AOSD : A MDA-based Approach</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>193-197</pages><keywords><keyword>aspects</keyword><keyword>model driven development</keyword><keyword>software architecture</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Software evolution in AOSD a MDA-based approach.pdf</url></pdf-urls></urls><label>Brazil;Dpto. Lenguajes y Ciencias de la Computacion;Europe;Federal University of Rio Grande do Norte;Federal University of Rio de Jeneiro;South America;Spain</label><abstract>In this paper we present a model-based approach to tackle the fragility pointcut problem that occurs in Aspect Oriented Systems. We focus on evaluating our work aiming at demonstrating that the definition of model-based pointcuts at early stages of the development can improve the software evolution in AOSD.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Saudrais, Sébastien</author><author>Chaaban, Khaled</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Automatic Relocation of AUTOSAR Components among Several ECUs</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>199-203</pages><keywords/><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Automatic relocation of AUTOSAR components among several ECUs.pdf</url></pdf-urls></urls><label>ESTACA;Europe;France;University</label><abstract>Today, embedded systems aremore and more involved in the definition of new and emergent functionalities of the vehicles and are developed by different component providers. This heterogeneity of origins complicates the integration and the validation of such systems. The standard AUTOSAR has been introduced to address this problem with the use, and reuse, of software components. But during the development phases, the AUTOSAR system architecture is often modified due to scheduling constraints, optimization or evolution and has to be manually maintained by the designer. During these different phases, software components are manually exchanged between different control units and these actions are error prone and time-consuming. The objective of this paper is to propose a method to automatically maintain the AUTOSAR architecture by providing a model transforma- tion when a software component needs to be relocated from an ECU to another one.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Tambe, Sumant</author><author>Gokhale, Aniruddha</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Rectifying Orphan Components using Group-Failover in Distributed Real-time and Embedded Systems</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>139-148</pages><keywords><keyword>Component-based systems</keyword><keyword>Soft Real-time and Fault tolerance</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Rectifying orphan components using group-failover in distributed real-time and embedded systems.pdf</url></pdf-urls></urls><label>North America;USA;University;Vanderbilt University</label><abstract>Orphan requests are a significant problem for multitier distributed systems since they adversely impact system correctness by violating the exactly-once semantics of applications and may waste resources. Orphan requests stem from the failure(s) of non-deterministic components involved in nested invocations of replicated components. Resolving this problem in the context of resource constrained, component- based, distributed real-time and embedded (DRE) systems that form end-to-end task chains is challenging because conventional transaction-based solutions cannot assure real-time properties of the DRE applications. To address these challenges, this paper presents a group-failover protocol that comprises three key capabilities: real-time failure detection and client failover, timelymitigation of orphan requests, and two novel application state consistency strategies to ensure the correctness of DRE systems by maintaining the exactly- once semantics even during failures. Our solution is implemented in the context of the CIAO real-time CORBA ComponentModel middleware. Empirical evaluations of the group-failover protocol in both fault-free and failure recovery scenarios for DRE task chains of different sizes demonstrates a low overhead and predictable performance.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Tibermacine, Chouki</author><author>Sadou, Salah</author><author>Dony, Christophe</author><author>Fabresse, Luc</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Component-Based Specification of Software Architecture Constraints Categories and Subject Descriptors</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>31-40</pages><keywords><keyword>architecture constraint</keyword><keyword>architecture description language</keyword><keyword>constraint component</keyword><keyword>constraint reuse and composition</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Component-based specification of software architecture constraints.pdf</url></pdf-urls></urls><label>Ecole des mines de Douai;Europe;France;Montpellier II University;Private Company;Universite Bretagne-Sud;University</label><abstract>Component-based software engineering provides for developers the ability to easily reuse and assemble software entities to build complex software. Component-based specification of software functional characteristics has been and is largely addressed, however this is not yet the case for what concerns software non-functional characteristics. In this paper, we propose a new way to express component-based software non-functional documentation, and we will focus more specifically on architecture constraints which formalize parts of architecture decisions, as executable, customizable, reusable and composable building blocks represented by components. Checking of architecture constraints is provided via service invocation through ports of a special kind of components, called constraint-components. The signatures of these checking services can be defined in required inter- faces of business components, to document decisions taken while designing their architecture. They can also be part of other required interfaces of constraint components, making it possible to build higher-level or more complex constraints while reusing existing ones. We present an example of implementation of constraint components using, an ADL which is introduced in this paper. Architecture constraints can then be checked on the architecture of business components at design-time using the CLACS tool support, which has been implemented as an Eclipse plugin.</abstract></record><record><database name="2011.enl" path="2011.enl">2011.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Yoon, Ilchul</author><author>Sussman, Alan</author><author>Memon, Atif</author><author>Porter, Adam</author></authors><secondary-authors><author>Crnkovic, Ivica</author><author>Stafford, Judith A</author></secondary-authors></contributors><titles><title>Towards Incremental Component Compatibility Testing</title><secondary-title>Proceedings of the 16th international workshop on Component-oriented programming</secondary-title></titles><periodical><full-title>Proceedings of the 16th international workshop on Component-oriented programming</full-title></periodical><pages>119-128</pages><keywords><keyword>compatibility</keyword><keyword>incremental testing</keyword><keyword>software component</keyword></keywords><dates><year>2011</year></dates><pub-location>Boulder, USA</pub-location><isbn>9781450307239</isbn><urls><pdf-urls><url>internal-pdf://Towards incremental component compatibility testing.pdf</url></pdf-urls></urls><label>North America;USA;University;University of Maryland</label><abstract>Software components are increasingly assembled from other components. Each component may further depend on others, and each may have multiple active versions. The total number of configurations—combinations of components and their versions—deployed by end users can be very large. Component developers, therefore, spend considerable time and effort doing compatibility testing – determining whether their components can be built correctly for all deployed con- figurations. In previous work we developed Rachet to support large-scale compatibility testing of components. In this paper, we describe and evaluate methods to enable Rachet to perform incremental compatibility testing. We describe algorithms to compute differences in component com- patibilities between current and previous component builds, a formal test adequacy criterion based on covering the differ- ences, and cache-aware configuration sampling and testing methods that attempt to reuse effort from previous testing sessions. We evaluate our approach using the 5-year evolution history of a scientific middleware component. Our results show significant performance improvements over Ra- chet’s previous retest-all approach, making the process of compatibility testing practical for evolving components.</abstract></record></records></xml>
