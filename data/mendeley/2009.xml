<?xml version="1.0" encoding="UTF-8"?><xml><records><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Bickford, Mark</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Component Specification Using Event Classes</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>140-155</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Bickford - 2009 - Component Specification Using Event Classes.pdf</url></pdf-urls></urls><label>Cornell University Computer Science and ATC-NY;New York;North America;University</label><abstract>Working in a higher-order, abstract logic of events,we define event classes, a generalization of interfaces, and propagation rules that specify information flow between event classes.We propose a general definition of a component as a scheme, parameterized by a set of input classes, that defines a set of output classes and propagation rules. The specification of a component is a relation between its input classes and defined output classes that follows from its propagation rules and definitions. We define a subset of programmable event classes that can be compiled and executed and a language, called E#, for specifying components. Components specified in E# preserve programmability–if the component’s input classes are programmable then its output classes and propagation rules are programmable. Thus a component specified in E# is a higher-order object: given programs for its input classes, it produces a distributed program for propagating information and programs for its output classes. These programs can be passed as inputs to other components so that components can be composed.</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Birkmeier, Dominik</author><author>Overhage, Sven</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>On Component Identification Approaches – Classification, State of the Art , and Comparison</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>1-18</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Birkmeier, Overhage - 2009 - On Component Identification Approaches – Classification , State of the Art , and Comparison.pdf</url></pdf-urls></urls><label>Business Informatics and Systems Engineering Chair;Component and Service Engineering Group;Europe;Germany;University;University of Augsburg</label><abstract>Partitioning a design space to identify components with desired nonfunctional and behavioral characteristics is a crucial task in the component-based software development process. Accordingly, the issue of how to analyze design models in order to systematically derive a set of components constitutes a research questionwhich has been investigated repeatedly. Component identification approaches that have been published in literature, however, make use of different component definitions and identification strategies. Furthermore, they vary from adhoc findings and general recommendations to more formalized methods and techniques which aim at an optimized partitioning. In this paper, we elaborate on the state of the art in component identification and provide a classification of approaches that highlights their respective strengths and weaknesses. To classify component identification approaches, we introduce a classification scheme that contains important distinguishing factors. It is used to compare existing ap- proaches which have been compiled during a literature survey. In addition, it provides the basis to discuss significant differences between them and to identify remaining issues which give information about future research directions</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Botaschanjan, Jewgenij</author><author>Harhurin, Alexander</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Integrating Functional and Architectural Views of Reactive Systems</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>156-172</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Botaschanjan, Harhurin - 2009 - Integrating Functional and Architectural Views of Reactive Systems.pdf</url></pdf-urls></urls><label>Europe;Germany;Institut für Informatik;Institute;TUMünchen</label><abstract>An integrated model-based development approach has to capture the relationship between requirements, design, and implementation models. In the requirements engineering phase, the most important view is the functional one, which specifies functionalities offered by the system and relationships between them. In the design phase, the component-based view describes the system as a network of interacting components. Via their interaction, they realize the black- box behavior specified in the functional view. To ensure the consistency between both views, a formal integration of them is necessary. The presented formal framework captures and interrelates both function- and component-based models. In particular, we provide a correct-by-construction procedure, which transforms a functional specification into a component-based architecture. Applicability of the method is evaluated in an industrial case study with the help of a CASE tool</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Crnkovic, Ivica</author><author>Ivano, Malavolta</author><author>Henry, Mucini</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>A Model-Driven Engineering Framework for Component Models Interoperability</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>36-53</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Crnkovic, Ivano, Henry - 2009 - A Model-Driven Engineering Framework for Component Models Interoperability.pdf</url></pdf-urls></urls><label>Dipartimento di Informatica;Europe;Italy;Malardalen Real-Time Research Centre;Malardalen University;Sweden;University;University of L’Aquila</label><abstract>Amultitude of component models exist today, characterized by slightly different conceptual architectural elements, focusing on a specific operational domain, covering different phases of component life-cycle, or supporting analysis of different quality attributes.When dealingwith different variants of products and in evolution of systems, there is a need for transformation of systemmodels fromone component model to another one.However, it is not obvious that different compo- nent models can accurately exchange models, due to their differences in concepts and semantics. This paper demonstrate an approach to achieve that.The paper proposes a generic framework to interchange models among component models. The framework, named DUALLY allows for tool and notations interpretability easing the transformation among many different component models. It is automated inside the Eclipse framework, and fully-extensible. The DUALLY approach is applied to two different component models for real-time embedded systems and observations are reported</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Gorton, Ian</author><author>Chase, Jared</author><author>Wynne, Adam</author><author>Almquist, Justin</author><author>Chappell, Alan</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Services + Components = Data Intensive Scientific Workflow Applications with MeDICi</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>227-241</pages><keywords><keyword>components</keyword><keyword>middleware</keyword><keyword>services</keyword><keyword>workflow</keyword></keywords><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Gorton et al. - 2009 - Services Components = Data Intensive Scientific Workflow Applications with MeDICi.pdf</url></pdf-urls></urls><label>Institute;North America;Pacific Northwest National Lab;USA</label><abstract>Scientific applications are often structured as workflows that execute a series of distributed software modules to analyze large data sets. Such workflows are typically constructed using general-purpose scripting languages to coordinate the execution of the various modules and to exchange data sets between them. While such scripts provide a costeffective approach for simple workflows, as the workflow structure becomes complex and evolves, the scripts quickly be- come complex and difficult to modify. This makes them a major barrier to easily and quickly deploying new algorithms and exploiting new, scalable hardware platforms. In this paper, we describe the MeDICi Workflow technology that is specifically designed to reduce the complexity of workflow application development, and to efficiently handle data intensive workflow applications. MeDICi integrates standard component-based and service-based technologies, and employs an efficient integration mechanism to ensure large data sets can be efficiently processed. We illustrate the use of MeDICi with a climate data process- ing example that we have built, and describe some of the new features we are creating to further enhance MeDICi Workflow applications</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Hauck, Michael</author><author>Kuperberg, Michael</author><author>Krogmann, Klaus</author><author>Reussner, Ralf</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Modelling Layered Component Execution Environments for Performance Prediction</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>191-208</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Hauck et al. - 2009 - Environments for Performance Prediction.pdf</url></pdf-urls></urls><label>Europe;FZI Research Center for Information Technology Kar;Germany;Institute;Software Design and Quality Group;Universitat Karlsruhe (TH);University</label><abstract>Software architects often use model-based techniques to analyse per- formance (e.g. response times), reliability and other extra-functional properties of software systems. These techniques operate on models of software architecture and execution environment, and are applied at design time for early evaluation of design alternatives, especially to avoid implementing systems with insufficient quality. Virtualisation (such as operating system hypervisors or virtual machines) and multiple layers in execution environments (e.g. RAID disk array controllers on top of hard disks) are becoming increasingly popular in reality and need to be reflected in the models of execution environments. However, current component meta-models do not support virtualisation and cannot model individual layers of execution environments. This means that the entire monolithic model must be recreated when different implementations of a layer must be compared to make a design decision, e.g. when comparing different Java Virtual Machines. In this paper, we present an extension of an established model-based performance pre- diction approach and associated tools which allow to model and predict state-of- the-art layered execution environments, such as disk arrays, virtual machines, and application servers. The evaluation of the presented approach shows its applicability and the resulting accuracy of the performance prediction while respecting the structure of the modelled resource environment</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Heineman, George T</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Unit Testing of Software Components with Inter-component Dependencies</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>262-273</pages><keywords><keyword>component dependencies</keyword><keyword>unit testing</keyword></keywords><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Heineman - 2009 - Unit Testing of Software Components with Inter-component Dependencies(3).pdf</url></pdf-urls></urls><label>Institute;North America;USA;Worcester Polytechnic Institute</label><abstract>Test Driven Development (TDD) is a process for software engineering that advocates constructing test cases before writing actual code; indeed, coding is treated as an exercise in validating the test cases. While such an ap- proach appeals to many software developers, one cannot simply apply TDD to component-based software engineering (CBSE). The primary obstacle is the more complex life cycle for software components that must be packaged, deployed and executed within software containers or deployment environments. In this paper we describe two case studies that show different ways by which TDD can be applied to CBSE. Our focus remains on the dependencies that exist between components and how to manage these dependencies during testing to still enable successful unit testing</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Hutchison, David</author><author>Mitchell, John C</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Introduction</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Hutchison, Mitchell - 2009 - Component-Based Software Engineering.pdf</url></pdf-urls></urls></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Kiniry, Joseph R</author><author>Fairmichael, Fintan</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Ensuring Consistency between Designs , Documentation , Formal Specifications , and Implementations</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>242-261</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Kiniry, Fairmichael - 2009 - Ensuring Consistency between Designs , Documentation , Formal Specifications , and Implementations.pdf</url></pdf-urls></urls><label>CASL: The Complex &amp; Adaptive Systems Laboratory;Europe;Ireland;School of Computer Science and Informatics and;University;University College Dublin</label><abstract>Software engineering experts and textbooks insist that all of the artifacts related to a system, (e.g., its design, documentation, and implementation), must be kept in-sync. Unfortunately, in the real world, it is a very rare case that any two of these are kept consistent, let alone all three. In general, as an im- plementation changes, its source code documentation, like that of Javadoc, is only occasionally updated at some later date. Unsurprisingly, most design doc- uments, like those written in UML, are created as a read-only mediumthey reflect what the designers thought they were building at one point in the past, but have little to do with the actual running system. Even those using formal meth- ods make this mistake, sometimes updating an implementation and forgetting to make some subtle change to a related specification. The critical problem inherent in this approach is that abstraction levels, while theoretically inter-dependent, are actually completely independent in semantics and from the point of view of the tools in pervasive use. Entities in different layers have no formal relation- ship; at best, informal relations are maintained by ad hoc approaches like code markers, or code is generated once and never touched again. This paper presents a new approach to system design, documentation, implementation, specification, and verification that imposes a formal refinement relationship between abstrac- tion levels that is invisible to the programmer and automatically maintained by an integrated set of tools. The new concept that enables this approach is called a semantic property, and their use is discussed in detail with a set of examples using the high-level specification language EBON, the detailed design and specifica- tion language JML, and the Java programming language as the implementation language.</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Lau, Kung-kiu</author><author>Ornaghi, Mario</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Control Encapsulation : A Calculus for Exogenous Composition of Software Components</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>121-139</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Lau, Ornaghi - 2009 - Control Encapsulation A Calculus for Exogenous Composition of Software Components.pdf</url></pdf-urls></urls><label>Dipartimento di Scienze dell’Informazione;Europe;Italy;School of Computer Science;United Kingdom;Universita’ degli studi di Milano Via Comelico;University;the University of Machnester</label><abstract>In current software components models, components do not encapsulate control, and are composed by connection mechanisms which pass control from component to component. Connection mechanisms are not hierarchical in general, and therefore current component models do not support hierarchical system construction. In this paper we argue that control encapsulation by components, together with suitable composition mechanisms, can lead to a component model that supports hierarchical system construction. We show an example of such amodel and present a calculus for its hierarchical composition mechanisms</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Lau, Kung-kiu</author><author>Taweel, Faris M</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Domain-Specific Software Component Models</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>19-35</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Lau, Taweel - 2009 - Domain-Specific Software Component Models.pdf</url></pdf-urls></urls><label>Europe;School of Computer Science;The University of Manchester;United Kingdom;University</label><abstract>We believe that for developing applications in a specific domain, the best kindof softwarecomponentmodel touse is adomain-specificone.We also be- lieve that current component models intended for specific domains are actually not domain-specific. In this paperwepresent an approach for deriving domain-specific component models fromthe domainmodel of a given domain, and showwhy such a component model is better than existing models that are not domain-specific</abstract></record><record><database name="2009.enl" path="2009.enl">2009.enl</database><ref-type name="Conference Proceedings">10</ref-type><contributors><authors><author>Navas, Juan</author><author>Babau, Jean-philippe</author><author>Lobry, Olivier</author><author>Frederic, Loiret</author></authors><secondary-authors><author>Grace A. Lewis, Iman Poernomo and Christine Hofmeister</author></secondary-authors></contributors><titles><title>Component-Based Real-Time Operating System for Embedded Applications</title><secondary-title>Component-Based Software Engineering 12th International Symposium, CBSE</secondary-title></titles><periodical><full-title>Component-Based Software Engineering 12th International Symposium, CBSE</full-title></periodical><pages>209-226</pages><keywords/><dates><year>2009</year></dates><pub-location>East Stroudsburg, PA, USA</pub-location><urls><pdf-urls><url>internal-pdf://Navas et al. - 2009 - Component-Based Real-Time Operating System for Embedded Applications(2).pdf</url></pdf-urls></urls><label>Europe;France;INRIA-Lille;Orange Labs;Private Company;Project ADAM;Universite Europeenne de Bretagne;University</label><abstract>As embedded systems must constantly integrate new functionalities, their developement cycles must be based on high-level abstractions, making the software design more flexible. CBSE provides an approach to these new requirements. However, low-level services provided by operating systems are an integral part of embedded applications, furthermore deployed on resource-limited devices. Therefore, the expected benefits of CBSE must not impact on the constraints imposed by the targetted do- main, such asmemory footprint, energy consumption, and execution time. In this paper, we present the componentization of a legacy industry- established Real-Time Operating System, and how component-based applications are built on top of it. We use the Think framework that allows to produce flexible systems while paying for flexibility only where desired. Performed experimentions show that the induced overhead is negligeable.</abstract></record></records></xml>
